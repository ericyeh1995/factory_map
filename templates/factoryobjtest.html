
<!DOCTYPE html>
<html lang="en">
    <head>
    <title>Factory threejs</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
     body {
         font-family: Monospace;
         background-color: #000;
         color: #fff;
         margin: 0px;
         overflow: hidden;
     }
     #info {
         color: #fff;
         position: absolute;
         top: 10px;
         width: 100%;
         text-align: center;
         z-index: 100;
         display:block;
     }
     #info a, .button { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
    </style>
    </head>

    <body>
    <div id="info">
        3D Factory
    </div>

        <script type="text/javascript" src="../static/three.js"></script>
        <script type="text/javascript" src="../static/OrbitControls.js"></script>
        <script type="text/javascript" src="../static/CSS2DRenderer.js"></script>

        <script type="text/javascript" src="../static/LoaderSupport.js"></script>
        <script type="text/javascript" src="../static/DDSLoader.js"></script>
        <script type="text/javascript" src="../static/MTLLoader.js"></script>
        <script type="text/javascript" src="../static/OBJLoader.js"></script>
        <script type="text/javascript" src="../static/OBJLoader2.js"></script>

        <script type="text/javascript" src="../static/Detector.js"></script>
        <script type="text/javascript" src="../static/stats.min.js"></script>

    <script>
        var machine_text = {
            "machine_01": {
                "text_name": "machine_01",
                "text_color": [128, 128, 128],
                "text_position": [1, -0.3, 0.8],
            },

            "machine_02": {
                "text_name": "machine_02",
                "text_color": [128, 128, 0],
                "text_position": [2, -0.3, 0.8]
            }
        };


        var container, stats;
        var camera, scene, renderer;
        var mouseX = 0,
            mouseY = 0;
        var windowHalfX = window.innerWidth / 2;
        var windowHalfY = window.innerHeight / 2;
        var pointLight, spotLight, spotLight2;

        var raycaster;
        var mouse = new THREE.Vector2(), INTERSECTED;
        var interactive_objects = [];


        init();
        animate();

        function init() {

            // SCENE
            scene = new THREE.Scene();

            // CAMERA AND CONTROL
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 100000);
            camera.position.z = 20000;
            camera.position.y = 20000;
            camera.position.x = 20000;
            scene.add(camera);

            controls = new THREE.OrbitControls(camera);
            controls.minDistance = 1000;
            controls.maxDistance = 50000;
            controls.enablePan = true;
            controls.maxPolarAngle = Math.PI / 2 + 0.1;

            // LIGHT
            var ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
            scene.add(ambientLight);

            spotLight = new THREE.SpotLight(0xffffff);
            spotLight.intensity = 2;
            spotLight.distance = 20000;
            spotLight.angle = Math.PI / 4;
            spotLight.decay = 1;
            spotLight.castShadow = true;
            spotLight.shadow.camera.near = 1;
            spotLight.shadow.camera.far = 5;
            spotLight.position.set(0, 10000, 0)
            scene.add(spotLight);

            spotLightHelper = new THREE.SpotLightHelper(spotLight);
            scene.add(spotLightHelper);

            // MODEL
            modelPath = "../static/models/collection/"
            modelNames = ['dam', 'e2', 'str37'];
            modelNames.forEach(function(modelName){

                var mtlLoader, objLoader
                THREE.Loader.Handlers.add(/\.dds$/i, new THREE.DDSLoader());
                mtlLoader = new THREE.MTLLoader();
                mtlLoader.setPath(modelPath);
                mtlLoader.setMaterialOptions({side: THREE.DoubleSide});
                mtlLoader.load(modelName+'.mtl', function(materials) {

                    materials.preload();
                    objLoader = new THREE.OBJLoader();
                    objLoader.setMaterials(materials);
                    objLoader.setPath(modelPath);
                    objLoader.load(modelName+'.obj', function(object) {

                        obj_mesh = object.children[0];
                        obj_mesh.receiveShadow = true;
                        obj_mesh.castShadow = true;
                        obj_mesh.position.set(0, 0, 0);
                        obj_mesh.name = modelName;
                        
                        // INTERACTION CODE - variable for scaling
                        obj_mesh.geometry.computeBoundingBox();
                        var geometryBox = obj_mesh.geometry.boundingBox;
                        obj_mesh.middle = new THREE.Vector3();
                        obj_mesh.middle.x = (geometryBox.max.x + geometryBox.min.x) / 2;
                        obj_mesh.middle.y = (geometryBox.max.y + geometryBox.min.y) / 2;
                        obj_mesh.middle.z = (geometryBox.max.z + geometryBox.min.z) / 2;

                        // INTERACTIVE CODE - bounding box for selecting
                        var boundingGeometry = new THREE.BoxGeometry(
                            geometryBox.max.x - geometryBox.min.x,
                            geometryBox.max.y - geometryBox.min.y,
                            geometryBox.max.z - geometryBox.min.z);
                        var selectable = new THREE.Mesh( boundingGeometry, new THREE.MeshBasicMaterial({
                            color: 0x801010,
                            wireframe: true,
                            //opacity: 0.3
                        }));
                        selectable.position.set(obj_mesh.middle.x, obj_mesh.middle.y, obj_mesh.middle.z);
                        selectable.object = obj_mesh;
                        scene.add(selectable);
                        interactive_objects.push(selectable);


                        scene.add(obj_mesh);
                        console.log('OBJ file loaded: '+modelPath+modelName);

                    }, onProgress, onError);
                });
            });


            // GEOMETRY
            var box = new THREE.BoxGeometry(500, 500, 500);
            var box_mat = new THREE.MeshStandardMaterial(0.1, 0);
            var mesh = new THREE.Mesh(box, box_mat);
            mesh.castShadow = true;
            mesh.selectable = true;
            mesh.position.set(0, 500, 0);
            mesh.name = 'box'
            scene.add(mesh);


            // FLOOR
            var floor = new THREE.BoxGeometry(50000, 10, 50000);
            var floor_mat = new THREE.MeshStandardMaterial({
                color: 0x808080
            });
            floor_mat.roughness = 1;
            var mesh = new THREE.Mesh(floor, floor_mat);
            mesh.position.set(0, -5, 0);
            mesh.receiveShadow = true;
            mesh.name = 'floor'
            scene.add(mesh);

            // TEXT
            var texts = ["machine_01"]

            var text = document.createElement('div');
            text.className = 'label';
            text.textContent = texts[0]
            text.style.color = 'rgb(128,128,128)';

            var label = new THREE.CSS2DObject(text);
            label.position.set(2500, 500, 2800);
            scene.add(label);

            // INTERACTIVE
            raycaster = new THREE.Raycaster();
            document.addEventListener('mousemove', onDocumentMouseMove, false);

            // RENDERER
            container = document.createElement('div');
            document.body.appendChild(container);

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            renderer.gammaInput = true;
            renderer.gammaOutput = true;

            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // TEXT RENDERER
            labelRenderer = new THREE.CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0';
            labelRenderer.domElement.style.pointerEvents = 'none'
            container.appendChild(labelRenderer.domElement);

            // WINDOW        
            window.addEventListener('resize', onWindowResize, false);

            // STATS
            stats = new Stats();
            container.appendChild(stats.dom);

        } // end init

        function render() {

            // INTERACTIVE: INTERSECTIONS
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(interactive_objects);
            if (intersects.length > 0) {
                if (INTERSECTED != intersects[0].object) {
                    if (INTERSECTED) onDeselect(INTERSECTED);
                    INTERSECTED = intersects[0].object;
                    onSelect(INTERSECTED, 1.1);
                }
            } else {
                if (INTERSECTED) onDeselect(INTERSECTED);
                INTERSECTED = null;
            }

            // CAMERA ROTATE ON START
            // var timer = Date.now() * 0.0005;
            // camera.position.x = Math.cos( timer ) * 3;
            // camera.position.z = Math.sin( timer ) * 3;
            // camera.lookAt( cameraTarget );

            // NORMAL RENDER STUFF
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }


        // Helper functions
        function animate() {
            requestAnimationFrame(animate);
            render();
            stats.update();
        }

        var onDeselect = function(mesh) { scaleLocal(mesh, 1); }
        var onSelect = function(mesh) { scaleLocal(mesh, 1.1); }

        function scaleLocal(box, scale) {
            // since the origin of the object is at global origin, we need some math in order to scale
            // locally
            mesh = box.object;
            mesh.scale.x = scale;
            mesh.scale.y = scale;
            mesh.scale.z = scale;

            var xShift = mesh.middle.x * (1 - scale);
            var yShift = mesh.middle.y * (1 - scale);
            var zShift = mesh.middle.z * (1 - scale);

            mesh.position.x = xShift;
            mesh.position.y = yShift;
            mesh.position.z = zShift;
        }

        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        var onProgress = function(xhr) {
            if (xhr.lengthComputable) {
                var percentComplete = xhr.loaded / xhr.total * 100;
                console.log(Math.round(percentComplete, 2) + '% downloaded');
            }
        };

        var onError = function(xhr) {};



    </script>

    </body>
</html>
